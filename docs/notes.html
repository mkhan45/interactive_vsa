<html>
    <head> 
        <title> Interactive VSA Synthesis </title>
    </head>
    <body style="max-width: 90ch; font-size: 1.1em">
        <h1> Interactive VSA Synthesis </h1>

        <a href="./generator.html">Link to the (very WIP) demo</a>

        <p>
        This repo started out as an interactive VSA synthesizer to explain the Duet
        algorithm. Since then, I've got a lot of ideas about using VSAs (eventually e-graphs)
        as a basis for an editor. This page is for notes and to help me explain stuff to people.
        </p>

        <h2> Structural Editing </h2>
        <p>
        Structural editors were inspired by the idea that text is a bad abstraction for programs.
        There are way more strings than there are valid programs, so a lot of effort in IDEs is
        spent making sure that you don't type invalid programs. Structural editors instead
        focus on the structure of the program, which has resulted in some really cool work.
        </p>
        <p>
        ASTs are *the* abstraction for programs. I don't know if there are any alternatives.
        However, usually programmers are not trying to write a program, instead they are trying
        to express an algorithm. I would argue that ASTs are not the best abstraction for
        algorithms for similar reasons that text is not the best abstraction for programs.
        For a given algorithm, there are many possible valid programs. Usually, for a given
        piece of code, we don't care about the structure of the program, we care about the
        algorithm that it represents.
        </p>
        <p>
        E-graphs and VSAs mostly solve this. Traditional VSAs represent a specific program
        behavior; that's most of the way to precisely representing a given algorithm, the
        only loss is runtime. I think it's probably possible to allow VSAs to distinguish
        runtimes though. This is also a weird direction of thought because we probably don't
        care about slower ways to write the same behavior.
        <p>

        <h2> VSA Editing </h2>
        <p>
        Structural editors are conceptually simple since it's easy to "type" an AST. VSA
        editing is a bit harder to visualize, since VSAs represent a potentially very large set
        of programs. In fact, it's difficult to even visualize a VSA for simple tasks, since
        there are so many possible programs.
        </p>
        <p>
        This section will have some speculation on different ideas.
        </p>
        <h3> Sketching </h3>
        <p>
        The traditional way to generate a VSA is by automatically synthesizing one that satisfies
        a set of Input/Output examples. However, this is currently limited to pretty small
        programs.
        </p>
        <p>
        One of the biggest reasons for this is that inverse semantics are hard. The number
        of possible ways to generate an output from an input is often exponential. It's often
        easy for a human to filter out the bad ones, but it's hard to do that automatically. However,
        it's really easy for a computer to check if a given program fits some inverse semantics.
        Another benefit of this is that, since the inverse semantics don't have to be convenient,
        we can use any language for this step, not just a small DSL.
        </p>
        <p>
        We can use the idea of program sketching. For the root of the VSA, a user can write
        some intermediate sketch, and the computer can check if it fits the inverse semantics.
        The user can continually refine the program this way until the subproblems are simple
        enough to be solved by the computer.
        </p>
        <p>
        I'm planning to implement this idea in the demo with JavaScript integration whenever
        I find time.
        </p>
        <h3> Refining the Specification </h3>
        <p>
        One of the biggest challenges of synthesis at large is that specifications are often
        just as hard to write as the program itself. It would be really cool for the editor
        to help the user refine their specification.
        </p>
        <p>
        One idea is to use SMT solvers to find an input that maximally distinguishes a set of 
        programs, pruning the VSA. Users can provide one input/output example, and then the editor 
        can synthesize a VSA that satisfies that example. Then, the editor can generate an input
        that maximally distinguishes the programs in the VSA, and ask the user which output
        they expect. This can be repeated until the user is satisfied with the specification.
        </p>
        <h3> Specifying Sub VSAs </h3>
        <p>
        Aside from refining the specification for the whole problem, users should be able
        to find a sub VSA of some synthesis result and then refine its specification. This
        would be useful since it reduces the problem size, and it might also be easier to
        specify.
        </p>
        <p>
        The inverse is also interesting: users could create an underspecified VSA, and then
        refine its specification by adding it as a child of a larger VSA. Then, the parent
        VSA's specification can be used to refine the child.
        </p>
        <h3> Giving the Synthesizer more info </h3>
        <p>
        There is a lot of information that the user has that the synthesizer doesn't. For example,
        for string synthesis, the user might know which parts of the string are important. FlashFill++
        uses heuristics to guess information like this, but it's not always right.
        </p>
        <p>
        It would be cool if the user could easily provide this information to the synthesizer.
        For example, the user could highlight parts of the input that are important, or parts
        of the output that are important. It would be pretty easy to use this information for
        VSA synthesis.
        </p>
        <h3> Heuristic Suggestions </h3>
        <p>
        Heuristics for synthesis are hard. However, they are probably getting better. It might
        be helpful for the editor to suggest possible operations to the user.
        </p>
    </body>
</html>
